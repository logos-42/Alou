// src/modelcontextprotocol/toolkit.ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

// src/shared/configuration.ts
function isToolAllowed(tool, configuration) {
  for (const product in tool.actions) {
    for (const action in tool.actions[product]) {
      if (configuration.actions[product] && configuration.actions[product][action]) {
        return true;
      }
    }
  }
  return false;
}

// src/shared/functions.ts
import axios from "axios";

// src/shared/payloadUtils.ts
import { round } from "mathjs";
import { snakeCase, camelCase } from "lodash";

// src/shared/constants.ts
var updateSubscriptionPathMapping = {
  ["outstanding_balance" /* outstandingBalance */]: "/billing_info/outstanding_balance",
  ["custom_id" /* customId */]: "/custom_id",
  ["fixed_price" /* fixedPrice */]: "/plan/billing_cycles/@sequence=={0}/pricing_scheme/fixed_price",
  ["payment_failure_threshold" /* paymentFailureThreshold */]: "/plan/payment_preferences/payment_failure_threshold",
  ["auto_bill_outstanding" /* autoBillOutstanding */]: "/plan/payment_preferences/auto_bill_outstanding",
  ["taxes_inclusive" /* taxesInclusive */]: "/plan/taxes/inclusive",
  ["taxes_percentage" /* taxesPercentage */]: "/plan/taxes/percentage",
  ["shipping_amount" /* shippingAmount */]: "/shipping_amount",
  ["shipping_address" /* shippingAddress */]: "/subscriber/shipping_address"
};

// src/shared/payloadUtils.ts
import debug from "debug";
var logger = debug("agent-toolkit:payloadUtils");
function parseOrderDetails(params) {
  try {
    const currCode = params.currencyCode;
    let items = [];
    const subTotal = params.items.reduce((sum, item) => sum + item.itemCost * item.quantity, 0);
    const shippingCost = params.shippingCost || 0;
    const taxAmount = params.items.reduce((sum, item) => sum + item.itemCost * item.taxPercent * item.quantity / 100, 0);
    const discount = params.discount || 0;
    const total = subTotal + taxAmount + shippingCost - discount;
    const amountBreakdown = {
      item_total: {
        value: round(subTotal, 2).toString(),
        currency_code: currCode
      },
      shipping: {
        value: round(shippingCost, 2).toString(),
        currency_code: currCode
      },
      tax_total: {
        value: round(taxAmount, 2).toString(),
        currency_code: currCode
      },
      discount: {
        value: round(discount, 2).toString(),
        currency_code: currCode
      }
    };
    params.items.forEach((item) => {
      items.push({
        name: item.name,
        description: item.description,
        unit_amount: {
          value: item.itemCost.toString() || "0",
          currency_code: currCode
        },
        quantity: item.quantity.toString() || "1",
        tax: {
          value: round(item.itemCost * item.taxPercent / 100, 2).toString() || "0",
          currency_code: currCode
        }
      });
    });
    const basePurchaseUnit = {
      amount: {
        value: round(total, 2).toString(),
        currency_code: currCode,
        breakdown: amountBreakdown
      },
      items
    };
    const purchaseUnit = params.shippingAddress ? { ...basePurchaseUnit, shipping: { address: params.shippingAddress } } : basePurchaseUnit;
    const request = {
      intent: "CAPTURE",
      purchase_units: [purchaseUnit]
    };
    if (params.returnUrl || params.cancelUrl) {
      request.payment_source = {
        paypal: {
          experience_context: {
            return_url: params.returnUrl,
            cancel_url: params.cancelUrl
          }
        }
      };
    }
    return request;
  } catch (error) {
    console.error(error);
    throw new Error("Failed to parse order details");
  }
}
var subscriptionKeysWithAddOperations = ["custom_id" /* customId */, "taxes_inclusive" /* taxesInclusive */, "taxes_percentage" /* taxesPercentage */, "shipping_amount" /* shippingAmount */, "shipping_address" /* shippingAddress */];
var parseUpdateSubscriptionPayload = (params, subscriptionDetails) => {
  const currCode = params.currency_code || "USD";
  const operations = [];
  for (let key in params) {
    if (key === "subscription_id" /* subscriptionId */ || key === "currency_code" /* currencyCode */) continue;
    const path = updateSubscriptionPathMapping[key];
    if (!path) {
      throw new Error(`Unsupported field for update: ${key}`);
    }
    let op = "replace";
    if (subscriptionKeysWithAddOperations.includes(key)) {
      const pathArray = path.split("/");
      pathArray.shift();
      const doesValueExist = pathArray.reduce((obj, key2) => obj?.[key2], subscriptionDetails);
      if (doesValueExist === void 0) op = "add";
    }
    let opItem = { op, path };
    let opValue = params[key];
    if (key === "fixed_price" /* fixedPrice */) {
      opItem.path = path.replace("{0}", opValue?.sequence || 1);
      delete opValue?.sequence;
      opValue = opValue?.value;
    }
    if (["outstanding_balance" /* outstandingBalance */, "shipping_amount" /* shippingAmount */, "fixed_price" /* fixedPrice */].includes(key)) {
      opItem.value = {
        currency_code: currCode,
        value: opValue
      };
    } else {
      opItem.value = opValue;
    }
    operations.push(opItem);
  }
  logger("Update Subscription Operations", JSON.stringify(operations));
  return operations;
};
function toQueryString(params) {
  return Object.entries(params).filter(([_, value]) => value !== void 0 && value !== null).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`).join("&");
}

// src/shared/functions.ts
import debug2 from "debug";
var logger2 = debug2("agent-toolkit:functions");
async function createInvoice(client, context, params) {
  logger2("[createInvoice] Starting invoice creation process");
  const headers = await client.getHeaders();
  logger2("[createInvoice] Headers obtained");
  const url = `${client.getBaseUrl()}/v2/invoicing/invoices`;
  logger2(`[createInvoice] API URL: ${url}`);
  try {
    logger2("[createInvoice] Sending request to PayPal API");
    const response = await axios.post(url, params, { headers });
    logger2(`[createInvoice] Invoice created successfully. Status: ${response.status}`);
    if (response.data && response.data.rel === "self" && response.data.href && response.data.href.includes("/v2/invoicing/invoices/") && response.data.method === "GET") {
      const hrefParts = response.data.href.split("/");
      const invoiceId = hrefParts[hrefParts.length - 1];
      logger2("[createInvoice] Automatically sending invoice with thank you note");
      try {
        const sendResult = await sendInvoice(client, context, {
          invoice_id: invoiceId,
          note: "thank you for choosing us. If there are any issues, feel free to contact us",
          send_to_recipient: true
        });
        return {
          createResult: response.data,
          sendResult
        };
      } catch (sendError) {
        logger2("[createInvoice] Error in auto-send invoice:", sendError.message);
        return response.data;
      }
    } else {
      logger2(`[createInvoice] Invoice ID: ${response.data.id || "N/A"}`);
      return response.data;
    }
  } catch (error) {
    logger2("[createInvoice] Error creating invoice:", error.message);
    handleAxiosError(error);
  }
}
async function listInvoices(client, context, params) {
  logger2("[listInvoices] Starting to list invoices");
  const headers = await client.getHeaders();
  logger2("[listInvoices] Headers obtained");
  const url = `${client.getBaseUrl()}/v2/invoicing/invoices`;
  logger2(`[listInvoices] API URL: ${url}`);
  try {
    logger2("[listInvoices] Sending request to PayPal API");
    const response = await axios.get(url, { headers, params });
    logger2(`[listInvoices] Invoices retrieved successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[listInvoices] Error listing invoices:", error.message);
    handleAxiosError(error);
  }
}
async function getInvoice(client, context, params) {
  logger2("[getInvoice] Starting to get invoice");
  const headers = await client.getHeaders();
  logger2("[getInvoice] Headers obtained");
  const url = `${client.getBaseUrl()}/v2/invoicing/invoices/${params.invoice_id}`;
  try {
    logger2("[getInvoice] Sending request to PayPal API");
    const response = await axios.get(url, { headers });
    logger2(`[getInvoice] Invoice retrieved successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[getInvoice] Error getting invoice:", error.message);
    handleAxiosError(error);
  }
}
async function sendInvoice(client, context, params) {
  logger2("[sendInvoice] Starting to send invoice");
  logger2(`[sendInvoice] Context: ${JSON.stringify({ sandbox: context.sandbox, merchant_id: context.merchant_id })}`);
  const {
    invoice_id,
    note,
    send_to_recipient,
    additional_recipients
  } = params;
  const headers = await client.getHeaders();
  logger2("[sendInvoice] Headers obtained");
  const url = `${client.getBaseUrl()}/v2/invoicing/invoices/${invoice_id}/send`;
  logger2(`[sendInvoice] API URL: ${url}`);
  try {
    logger2("[sendInvoice] Sending request to PayPal API");
    const response = await axios.post(url, params, { headers });
    logger2(`[sendInvoice] Invoice sent successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[sendInvoice] Error sending invoice:", error.message);
    handleAxiosError(error);
  }
}
async function sendInvoiceReminder(client, context, params) {
  logger2("[sendInvoiceReminder] Starting to send invoice reminder");
  const {
    invoice_id,
    note,
    subject,
    additional_recipients
  } = params;
  const headers = await client.getHeaders();
  logger2("[sendInvoiceReminder] Headers obtained");
  const url = `${client.getBaseUrl()}/v2/invoicing/invoices/${invoice_id}/remind`;
  try {
    logger2("[sendInvoiceReminder] Sending request to PayPal API");
    const response = await axios.post(url, params, { headers });
    logger2(`[sendInvoiceReminder] Invoice reminder sent successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[sendInvoiceReminder] Error sending invoice reminder:", error.message);
    handleAxiosError(error);
  }
}
async function cancelSentInvoice(client, context, params) {
  logger2("[cancelSentInvoice] Starting to cancel sent invoice");
  const {
    invoice_id,
    note,
    send_to_recipient,
    additional_recipients
  } = params;
  const headers = await client.getHeaders();
  logger2("[cancelSentInvoice] Headers obtained");
  const url = `${client.getBaseUrl()}/v2/invoicing/invoices/${invoice_id}/cancel`;
  try {
    logger2("[cancelSentInvoice] Sending request to PayPal API");
    const response = await axios.post(url, params, { headers });
    if (response.status === 204) {
      logger2(`[cancelSentInvoice] Invoice cancelled successfully. Status: ${response.status}`);
      return { success: true, invoice_id };
    }
    logger2(`[cancelSentInvoice] Invoice cancellation response received. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[cancelSentInvoice] Error cancelling invoice:", error.message);
    handleAxiosError(error);
  }
}
async function generateInvoiceQrCode(client, context, params) {
  const { invoice_id } = params;
  const requestBody = {
    width: params.width,
    height: params.height
  };
  const url = `${client.getBaseUrl()}/v2/invoicing/invoices/${invoice_id}/generate-qr-code`;
  const headers = await client.getHeaders();
  logger2("[generateInvoiceQrCodePrompt] Headers obtained");
  try {
    logger2("[cancelSentInvoice] Sending request to PayPal API");
    const response = await axios.post(url, requestBody, { headers });
    if (response.status === 204) {
      logger2(`[cancelSentInvoice] Invoice cancelled successfully. Status: ${response.status}`);
      return { success: true, invoice_id };
    }
    logger2(`[cancelSentInvoice] Invoice cancellation response received. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[cancelSentInvoice] Error cancelling invoice:", error.message);
    handleAxiosError(error);
  }
}
async function createProduct(client, context, params) {
  const headers = await client.getHeaders();
  const apiUrl = `${client.getBaseUrl()}/v1/catalogs/products`;
  logger2(`[createProduct] Payload: ${JSON.stringify(params, null, 2)}`);
  try {
    const response = await axios.post(apiUrl, params, { headers });
    return response.data;
  } catch (error) {
    console.error("Error Creating Product:", error.response?.data || error);
    throw error;
  }
}
async function listProducts(client, context, params) {
  const headers = await client.getHeaders();
  const { page = 1, page_size = 2, total_required = true } = params;
  const apiUrl = `${client.getBaseUrl()}/v1/catalogs/products?page_size=${page_size}&page=${page}&total_required=${total_required}`;
  try {
    const response = await axios.get(apiUrl, { headers });
    return response.data;
  } catch (error) {
    console.error("Error Listing Product:", error.response?.data || error);
    throw error;
  }
}
async function showProductDetails(client, context, params) {
  const headers = await client.getHeaders();
  const apiUrl = `${client.getBaseUrl()}/v1/catalogs/products/${params.product_id}`;
  try {
    const response = await axios.get(apiUrl, {
      headers
    });
    return response.data;
  } catch (error) {
    console.error("Error Show Product Details:", error.response?.data || error);
    throw error;
  }
}
async function createSubscriptionPlan(client, context, params) {
  const headers = await client.getHeaders();
  const apiUrl = `${client.getBaseUrl()}/v1/billing/plans`;
  logger2(`[createSubscriptionPlan] Payload: ${JSON.stringify(params, null, 2)}`);
  try {
    const response = await axios.post(apiUrl, params, { headers });
    return response.data;
  } catch (error) {
    console.error("Error Creating Plan:", error.response?.data || error);
    throw error;
  }
}
async function listSubscriptionPlans(client, context, params) {
  const { page = 1, page_size = 10, total_required = true, product_id } = params;
  let apiUrl = `${client.getBaseUrl()}/v1/billing/plans?page_size=${page_size}&page=${page}&total_required=${total_required}`;
  if (product_id) {
    apiUrl += `&product_id=${product_id}`;
  }
  const headers = await client.getHeaders();
  try {
    const response = await axios.get(apiUrl, {
      headers
    });
    return response.data;
  } catch (error) {
    console.error("Error Creating Plan:", error.response?.data || error);
    throw error;
  }
}
async function showSubscriptionPlanDetails(client, context, params) {
  const headers = await client.getHeaders();
  const apiUrl = `${client.getBaseUrl()}/v1/billing/plans/${params.plan_id}`;
  try {
    const response = await axios.get(apiUrl, {
      headers
    });
    return response.data;
  } catch (error) {
    console.error("Error Show Plan Details:", error.response?.data || error);
    throw error;
  }
}
async function createSubscription(client, context, params) {
  const headers = await client.getHeaders();
  const apiUrl = `${client.getBaseUrl()}/v1/billing/subscriptions`;
  logger2(`[createSubscription] Payload: ${JSON.stringify(params, null, 2)}`);
  try {
    const response = await axios.post(apiUrl, params, { headers });
    return response.data;
  } catch (error) {
    console.error("Error Creating Subscription:", error.response?.data || error);
    throw error;
  }
}
async function showSubscriptionDetails(client, context, params) {
  const headers = await client.getHeaders();
  const { subscription_id, get_additional_details } = params;
  const apiUrl = `${client.getBaseUrl()}/v1/billing/subscriptions/${subscription_id}${get_additional_details ? "?fields=plan" : ""}`;
  try {
    const response = await axios.get(apiUrl, {
      headers
    });
    return response.data;
  } catch (error) {
    console.error("Error Show Subscription Details:", error.response?.data || error);
    throw error;
  }
}
async function cancelSubscription(client, context, params) {
  const headers = await client.getHeaders();
  const { subscription_id, payload } = params;
  const apiUrl = `${client.getBaseUrl()}/v1/billing/subscriptions/${subscription_id}/cancel`;
  try {
    const response = await axios.post(apiUrl, payload, { headers });
    return response.data;
  } catch (error) {
    console.error("Error Creating Subscription:", error.response?.data || error);
    throw error;
  }
}
async function updateSubscription(client, context, params) {
  const headers = await client.getHeaders();
  const { subscription_id } = params;
  try {
    const subscriptionDetails = await showSubscriptionDetails(client, context, { subscription_id, get_additional_details: true });
    const operations = parseUpdateSubscriptionPayload(params, subscriptionDetails);
    const apiUrl = `${client.getBaseUrl()}/v1/billing/subscriptions/${subscription_id}`;
    const response = await axios.patch(apiUrl, operations, { headers });
    return response.data;
  } catch (error) {
    logger2("[updateSubscription] Error updating subscription:", JSON.stringify(error.message));
    handleAxiosError(error);
  }
}
var createOrder = async (client, context, params) => {
  logger2("[createOrder] Starting order creation process");
  const headers = await client.getHeaders();
  const url = `${client.getBaseUrl()}/v2/checkout/orders`;
  const orderRequest = parseOrderDetails(params);
  try {
    const response = await axios.post(url, orderRequest, { headers });
    logger2(`[createOrder] Order created successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[createOrder] Error creating order:", error.message);
    handleAxiosError(error);
  }
};
var getOrder = async (client, context, params) => {
  logger2("[getOrder] Starting order retrieval process");
  logger2(`[getOrder] Context: ${JSON.stringify({ sandbox: context.sandbox, merchant_id: context.merchant_id })}`);
  logger2(`[getOrder] Order ID: ${params.id}`);
  const headers = await client.getHeaders();
  logger2("[getOrder] Headers obtained");
  const url = `${client.getBaseUrl()}/v2/checkout/orders/${params.id}`;
  try {
    logger2("[getOrder] Sending GET request to PayPal API");
    const response = await axios.get(url, { headers });
    logger2(`[getOrder] Order retrieved successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[getOrder] Error retrieving order:", error.message);
    handleAxiosError(error);
  }
};
var captureOrder = async (client, context, params) => {
  try {
    logger2(`[captureOrder] Starting order capture process with params: ${JSON.stringify(params)}`);
    const url = `${client.getBaseUrl()}/v2/checkout/orders/${params.id}/capture`;
    const response = await axios.post(url, {}, {
      headers: await client.getHeaders()
    });
    logger2(`[captureOrder] Response %s`, response);
    if (response.status <= 299) {
      return {
        status: "success",
        response: response.data
      };
    } else {
      return {
        status: "error",
        response: response.data
      };
    }
  } catch (error) {
    console.error(error);
    throw new Error("Failed to capture order");
  }
};
async function createShipment(client, context, params) {
  logger2("[createShipment] Starting shipment tracking creation process");
  const {
    tracking_number,
    transaction_id,
    status,
    carrier
  } = params;
  const headers = await client.getHeaders();
  logger2("[createShipment] Headers obtained");
  const url = `${client.getBaseUrl()}/v1/shipping/trackers-batch`;
  logger2(`[createShipment] API URL: ${url}`);
  const trackersData = {
    trackers: [{
      tracking_number,
      transaction_id,
      status,
      carrier
    }]
  };
  try {
    logger2("[createShipment] Sending request to PayPal API");
    const response = await axios.post(url, trackersData, { headers });
    logger2(`[createShipment] Shipment tracking created successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[createShipment] Error creating shipment tracking:", error.message);
    handleAxiosError(error);
  }
}
async function getShipmentTracking(client, context, params) {
  logger2("[getShipmentTracking] Starting to get shipment tracking information");
  const {
    transaction_id: providedTransactionId,
    order_id
  } = params;
  const headers = await client.getHeaders();
  logger2("[getShipmentTracking] Headers obtained");
  let transaction_id = providedTransactionId;
  if (order_id && !providedTransactionId) {
    logger2("[getShipmentTracking] order_id provided but transaction_id is missing. Attempting to extract transaction_id from order details.");
    try {
      const orderDetails = await getOrder(client, context, { id: order_id });
      if (orderDetails && orderDetails.purchase_units && orderDetails.purchase_units.length > 0) {
        const purchaseUnit = orderDetails.purchase_units[0];
        if (purchaseUnit.payments && purchaseUnit.payments.captures && purchaseUnit.payments.captures.length > 0) {
          const captureDetails = purchaseUnit.payments.captures[0];
          transaction_id = captureDetails.id;
        } else {
          throw new Error("Could not find capture id in the purchase unit details.");
        }
      } else {
        throw new Error("Could not find purchase unit details in order details.");
      }
    } catch (error) {
      logger2(`[getShipmentTracking] Error extracting transaction_id from order details: ${error.message}`);
      throw new Error(`Error extracting transaction_id from order details: ${error.message}`);
    }
  } else if (!providedTransactionId) {
    throw new Error("Either transaction_id or order_id must be provided.");
  }
  const url = `${client.getBaseUrl()}/v1/shipping/trackers?transaction_id=${transaction_id}`;
  logger2(`[getShipmentTracking] API URL: ${url}`);
  try {
    logger2("[getShipmentTracking] Sending request to PayPal API");
    const response = await axios.get(url, { headers });
    logger2(`[getShipmentTracking] Shipment tracking retrieved successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[getShipmentTracking] Error retrieving shipment tracking:", error.message);
    handleAxiosError(error);
  }
}
async function listDisputes(client, context, params) {
  logger2("[listDisputes] Starting to list disputes");
  const headers = await client.getHeaders();
  logger2("[listDisputes] Headers obtained");
  const url = `${client.getBaseUrl()}/v1/customer/disputes?${toQueryString(params)}`;
  try {
    logger2("[listDisputes] Sending request to PayPal API");
    const response = await axios.get(url, { headers, params });
    logger2(`[listDisputes] Disputes retrieved successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[listDisputes] Error listing disputes:", error.message);
    handleAxiosError(error);
  }
}
async function getDispute(client, context, params) {
  const { dispute_id } = params;
  const headers = await client.getHeaders();
  logger2("[getDispute] Headers obtained");
  const url = `${client.getBaseUrl()}/v1/customer/disputes/${dispute_id}`;
  logger2(`[getDispute] API URL: ${url}`);
  try {
    logger2("[getDispute] Sending request to PayPal API");
    const response = await axios.get(url, { headers });
    logger2(`[getDispute] Dispute details retrieved successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2(`[getDispute] Error retrieving dispute details for ID: ${dispute_id}:`, error.message);
    handleAxiosError(error);
  }
}
async function acceptDisputeClaim(client, context, params) {
  logger2("[acceptClaim] Starting to list disputes");
  const headers = await client.getHeaders();
  logger2("[acceptClaim] Headers obtained");
  const url = `${client.getBaseUrl()}/v1/customer/disputes/${params.dispute_id}/accept-claim`;
  logger2(`[acceptClaim] API URL: ${url}`);
  try {
    logger2("[acceptClaim] Sending request to PayPal API");
    const response = await axios.post(url, { note: params.note }, { headers, params });
    logger2(`[acceptClaim] Disputes retrieved successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2("[acceptClaim] Error listing disputes:", error.message);
    handleAxiosError(error);
  }
}
async function listTransactions(client, context, params) {
  const headers = await client.getHeaders();
  logger2("[listTransactions] Headers obtained");
  if (params.transaction_id) {
    logger2(`[listTransactions] Searching for transaction with ID: ${params.transaction_id}`);
    const searchMonths = params.search_months || 12;
    logger2(`[listTransactions] Will search up to ${searchMonths} months back for the transaction`);
    const endDate = /* @__PURE__ */ new Date();
    let startDate = /* @__PURE__ */ new Date();
    startDate.setDate(endDate.getDate() - 31);
    for (let month = 0; month < searchMonths; month++) {
      const queryParams = { ...params };
      delete queryParams.search_months;
      queryParams.end_date = endDate.toISOString();
      queryParams.start_date = startDate.toISOString();
      logger2(`[listTransactions] Searching month ${month + 1}: ${startDate.toISOString()} to ${endDate.toISOString()}`);
      const url = `${client.getBaseUrl()}/v1/reporting/transactions?${toQueryString(queryParams)}`;
      logger2(`[listTransactions] API URL: ${url}`);
      try {
        logger2("[listTransactions] Sending request to PayPal API");
        const response = await axios.get(url, { headers, params: queryParams });
        logger2(`[listTransactions] Transactions retrieved successfully. Status: ${response.status}`);
        if (response.data && response.data.transaction_details && response.data.transaction_details.length > 0) {
          const foundTransaction = response.data.transaction_details.find(
            (transaction) => transaction.transaction_info.transaction_id === params.transaction_id
          );
          if (foundTransaction) {
            logger2(`[listTransactions] Found transaction with ID: ${params.transaction_id}`);
            return {
              found: true,
              transaction_details: [foundTransaction],
              total_items: 1
            };
          }
        }
        endDate.setTime(startDate.getTime());
        startDate.setMonth(startDate.getMonth() - 1);
      } catch (error) {
        logger2(`[listTransactions] Error searching transactions for month ${month + 1}:`, error.message);
      }
    }
    logger2(`[listTransactions] Transaction with ID ${params.transaction_id} not found after searching ${searchMonths} months`);
    return {
      found: false,
      transaction_details: [],
      total_items: 0,
      message: `The transaction ID ${params.transaction_id} was not found in the last ${searchMonths} months. Please verify the transaction ID and try again, or let me know if there's anything else I can assist you with!`
    };
  } else {
    const queryParams = { ...params };
    delete queryParams.search_months;
    if (!queryParams.end_date && !queryParams.start_date) {
      queryParams.end_date = (/* @__PURE__ */ new Date()).toISOString();
      queryParams.start_date = new Date((/* @__PURE__ */ new Date()).getTime() - 31 * 24 * 60 * 60 * 1e3).toISOString();
    } else if (!queryParams.end_date) {
      const startDate = new Date(queryParams.start_date);
      queryParams.end_date = new Date(startDate.getTime() + 31 * 24 * 60 * 60 * 1e3).toISOString();
    } else if (!queryParams.start_date) {
      const endDate = new Date(queryParams.end_date);
      queryParams.start_date = new Date(endDate.getTime() - 31 * 24 * 60 * 60 * 1e3).toISOString();
    } else {
      const startDate = new Date(queryParams.start_date);
      const endDate = new Date(queryParams.end_date);
      const dayRange = (endDate.getTime() - startDate.getTime()) / (24 * 60 * 60 * 1e3);
      if (dayRange > 31) {
        queryParams.start_date = new Date(endDate.getTime() - 31 * 24 * 60 * 60 * 1e3).toISOString();
      }
    }
    const url = `${client.getBaseUrl()}/v1/reporting/transactions?${toQueryString(queryParams)}`;
    logger2(`[listTransactions] API URL: ${url}`);
    try {
      logger2("[listTransactions] Sending request to PayPal API");
      const response = await axios.get(url, { headers, params: queryParams });
      logger2(`[listTransactions] Transactions retrieved successfully. Status: ${response.status}`);
      return response.data;
    } catch (error) {
      logger2("[listTransactions] Error listing transactions:", error.message);
      handleAxiosError(error);
    }
  }
}
async function createRefund(client, context, params) {
  logger2(`[createRefund] Starting to refund capture for ID: ${params.capture_id}`);
  const { capture_id } = params;
  const headers = await client.getHeaders();
  logger2("[createRefund] Headers obtained");
  const url = `${client.getBaseUrl()}/v2/payments/captures/${capture_id}/refund`;
  logger2(`[createRefund] API URL: ${url}`);
  try {
    logger2("[createRefund] Sending request to PayPal API");
    const response = await axios.post(url, params, { headers });
    logger2(`[createRefund] Capture refunded successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2(`[createRefund] Error refunding capture for ID: ${capture_id}:`, error.message);
    handleAxiosError(error);
  }
}
async function getRefund(client, context, params) {
  logger2(`[getRefund] Starting to get refund details for ID: ${params.refund_id}`);
  const { refund_id } = params;
  const headers = await client.getHeaders();
  logger2("[getRefund] Headers obtained");
  const url = `${client.getBaseUrl()}/v2/payments/refunds/${refund_id}`;
  logger2(`[getRefund] API URL: ${url}`);
  try {
    logger2("[getRefund] Sending request to PayPal API");
    const response = await axios.get(url, { headers });
    logger2(`[getRefund] Refund details retrieved successfully. Status: ${response.status}`);
    return response.data;
  } catch (error) {
    logger2(`[getRefund] Error retrieving refund details for ID: ${refund_id}:`, error.message);
    handleAxiosError(error);
  }
}
function handleAxiosError(error) {
  logger2("[handleAxiosError] Processing error from PayPal API");
  if (error.response) {
    logger2(`[handleAxiosError] Response error status: ${error.response.status}`);
    logger2(`[handleAxiosError] Response error headers: ${JSON.stringify(error.response.headers)}`);
    try {
      const errorData = error.response.data;
      logger2(`[handleAxiosError] Error data: ${JSON.stringify(errorData)}`);
      let errorMessage = errorData.message || "Unknown error";
      if (errorData.details && Array.isArray(errorData.details)) {
        const detailDescriptions = errorData.details.map((detail) => detail.description || "").filter(Boolean).join("; ");
        if (detailDescriptions) {
          errorMessage += ": " + detailDescriptions;
          logger2(`[handleAxiosError] Error details: ${detailDescriptions}`);
        }
      }
      logger2(`[handleAxiosError] Throwing error with message: PayPal API error (${error.response.status}): ${errorMessage}`);
      throw new Error(`PayPal API error (${error.response.status}): ${errorMessage}`);
    } catch (e) {
      logger2("[handleAxiosError] Error parsing response data, using raw data");
      logger2(`[handleAxiosError] Throwing error with message: PayPal API error (${error.response.status}): ${error.response.data}`);
      throw new Error(`PayPal API error (${error.response.status}): ${error.response.data}`);
    }
  } else if (error.request) {
    logger2("[handleAxiosError] No response received from PayPal API");
    logger2(`[handleAxiosError] Request: ${JSON.stringify(error.request)}`);
    logger2(`[handleAxiosError] Throwing error with message: PayPal API error: No response received - ${error.message}`);
    throw new Error(`PayPal API error: No response received - ${error.message}`);
  } else {
    logger2(`[handleAxiosError] Error setting up request: ${error.message}`);
    logger2(`[handleAxiosError] Throwing error with message: PayPal API error: ${error.message}`);
    throw new Error(`PayPal API error: ${error.message}`);
  }
}

// src/shared/client.ts
import { Client, Environment, LogLevel } from "@paypal/paypal-server-sdk";
import axios2 from "axios";
import { Buffer } from "buffer";
import os from "os";

// package.json
var version = "1.3.5";

// src/shared/client.ts
import debug3 from "debug";
var logger3 = debug3("agent-toolkit:client");
var PayPalClient = class {
  _sdkClient;
  _clientId;
  _clientSecret;
  _isSandbox;
  _accessToken;
  _baseUrl;
  _context;
  constructor({ clientId, clientSecret, context, accessToken }) {
    this._context = context;
    const debugSdk = this._context.debug ?? false;
    this._clientId = clientId;
    this._clientSecret = clientSecret;
    this._isSandbox = this._context?.sandbox ?? false;
    this._accessToken = accessToken;
    if (this._clientId !== void 0 && this._clientSecret !== void 0) {
      this.createSDKClient(this._clientId, this._clientSecret, debugSdk);
    }
    this._baseUrl = this._isSandbox ? "https://api.sandbox.paypal.com" : "https://api.paypal.com";
    logger3(`[PayPal Setttings] Environment: ${this._isSandbox ? "Sandbox" : "Live"}`);
    logger3(`[PayPal Setttings] API Base: ${this._baseUrl}`);
  }
  createSDKClient(clientId, clientSecret, debugSdk) {
    this._sdkClient = new Client({
      clientCredentialsAuthCredentials: {
        oAuthClientId: clientId,
        oAuthClientSecret: clientSecret
      },
      timeout: 0,
      environment: this._isSandbox ? Environment.Sandbox : Environment.Production,
      ...debugSdk && {
        logging: {
          logLevel: LogLevel.Info,
          maskSensitiveHeaders: true,
          logRequest: {
            logBody: true
          },
          logResponse: {
            logBody: true,
            logHeaders: true
          }
        }
      }
    });
  }
  async getAccessToken() {
    const auth = Buffer.from(`${this._clientId}:${this._clientSecret}`).toString("base64");
    const url = this._baseUrl + "/v1/oauth2/token";
    try {
      const response = await axios2.post(
        url,
        "grant_type=client_credentials",
        {
          headers: {
            "Authorization": `Basic ${auth}`,
            "Content-Type": "application/x-www-form-urlencoded",
            "User-Agent": this.generateUserAgent()
          }
        }
      );
      return response.data.access_token;
    } catch (error) {
      if (axios2.isAxiosError(error)) {
        throw new Error(`Failed to fetch access token: ${error.response?.data?.error_description || error.message}`);
      } else {
        throw new Error(`Failed to fetch access token: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }
  // Helper method to get base URL
  getBaseUrl() {
    return this._baseUrl;
  }
  // Helper method to get headers
  async getHeaders() {
    const headers = {
      "Content-Type": "application/json"
    };
    this._accessToken = this._accessToken || await this.getAccessToken();
    headers["Authorization"] = `Bearer ${this._accessToken}`;
    if (this._context.request_id) {
      headers["PayPal-Request-Id"] = this._context.request_id;
    }
    if (this._context.tenant_context) {
      headers["PayPal-Tenant-Context"] = JSON.stringify(this._context.tenant_context);
    }
    headers["User-Agent"] = this.generateUserAgent();
    return headers;
  }
  generateUserAgent() {
    const components = [
      `PayPal Agent Toolkit Typescript: ${this._context.source}`,
      `Version: ${version}`,
      `on OS: ${os.platform()} ${os.release()}`
    ];
    return components.filter(Boolean).join(", ");
  }
};
var client_default = PayPalClient;

// src/shared/api.ts
var PayPalAPI = class {
  paypalClient;
  context;
  baseUrl;
  accessToken;
  constructor(paypalClientOrAccessToken, context) {
    this.context = context || {};
    this.context.sandbox = this.context.sandbox ?? false;
    this.baseUrl = this.context.sandbox ? "https://api-m.sandbox.paypal.com" : "https://api-m.paypal.com";
    if (typeof paypalClientOrAccessToken === "string") {
      this.accessToken = paypalClientOrAccessToken;
      this.paypalClient = new client_default({ context: this.context, accessToken: this.accessToken });
    } else {
      this.paypalClient = paypalClientOrAccessToken;
    }
  }
  async run(method, arg) {
    try {
      const output = await this.executeMethod(method, arg);
      return JSON.stringify(output);
    } catch (error) {
      const errorMessage = error.message || "Unknown error";
      return JSON.stringify({
        error: {
          message: errorMessage,
          type: "paypal_error"
        }
      });
    }
  }
  async executeMethod(method, arg) {
    switch (method) {
      case "create_invoice":
        return createInvoice(this.paypalClient, this.context, arg);
      case "list_invoices":
        return listInvoices(this.paypalClient, this.context, arg);
      case "get_invoice":
        return getInvoice(this.paypalClient, this.context, arg);
      case "send_invoice":
        return sendInvoice(this.paypalClient, this.context, arg);
      case "send_invoice_reminder":
        return sendInvoiceReminder(this.paypalClient, this.context, arg);
      case "cancel_sent_invoice":
        return cancelSentInvoice(this.paypalClient, this.context, arg);
      case "generate_invoice_qr_code":
        return generateInvoiceQrCode(this.paypalClient, this.context, arg);
      case "create_product":
        return createProduct(this.paypalClient, this.context, arg);
      case "list_products":
        return listProducts(this.paypalClient, this.context, arg);
      case "show_product_details":
        return showProductDetails(this.paypalClient, this.context, arg);
      case "create_subscription_plan":
        return createSubscriptionPlan(this.paypalClient, this.context, arg);
      case "list_subscription_plans":
        return listSubscriptionPlans(this.paypalClient, this.context, arg);
      case "show_subscription_plan_details":
        return showSubscriptionPlanDetails(this.paypalClient, this.context, arg);
      case "create_subscription":
        return createSubscription(this.paypalClient, this.context, arg);
      case "show_subscription_details":
        return showSubscriptionDetails(this.paypalClient, this.context, arg);
      case "cancel_subscription":
        return cancelSubscription(this.paypalClient, this.context, arg);
      case "update_subscription":
        return updateSubscription(this.paypalClient, this.context, arg);
      case "create_shipment_tracking":
        return createShipment(this.paypalClient, this.context, arg);
      case "get_shipment_tracking":
        return getShipmentTracking(this.paypalClient, this.context, arg);
      case "create_order":
        return createOrder(this.paypalClient, this.context, arg);
      case "get_order":
        return getOrder(this.paypalClient, this.context, arg);
      case "pay_order":
        return captureOrder(this.paypalClient, this.context, arg);
      case "list_disputes":
        return listDisputes(this.paypalClient, this.context, arg);
      case "get_dispute":
        return getDispute(this.paypalClient, this.context, arg);
      case "accept_dispute_claim":
        return acceptDisputeClaim(this.paypalClient, this.context, arg);
      case "list_transactions":
        return listTransactions(this.paypalClient, this.context, arg);
      case "create_refund":
        return createRefund(this.paypalClient, this.context, arg);
      case "get_refund":
        return getRefund(this.paypalClient, this.context, arg);
      default:
        throw new Error(`Invalid method: ${method}`);
    }
  }
};
var api_default = PayPalAPI;

// src/shared/prompts.ts
var createInvoicePrompt = (context) => `
Create Invoices on PayPal.

This function is used to create an invoice in the PayPal system. It allows you to generate a new invoice, specifying details such as customer information, items, quantities, pricing, and tax information. Once created, an invoice can be sent to the customer for payment.
`;
var listInvoicesPrompt = (context) => `
List invoices from PayPal.

This function retrieves a list of invoices with optional pagination parameters.
`;
var getInvoicePrompt = (context) => `
Get an invoice from PayPal.

This function retrieves details of a specific invoice using its ID.
`;
var sendInvoicePrompt = (context) => `
Send an invoice to the recipient(s).

This function sends a previously created invoice to its intended recipients.
`;
var sendInvoiceReminderPrompt = (context) => `
Send a reminder for an invoice.

This function sends a reminder for an invoice that has already been sent but hasn't been paid yet.
`;
var cancelSentInvoicePrompt = (context) => `
Cancel a sent invoice.

This function cancels an invoice that has already been sent to the recipient(s).
`;
var generateInvoiceQrCodePrompt = (context) => `
Generate a QR code for an invoice.

This function generates a QR code for an invoice, which can be used to pay the invoice using a mobile device or scanning app.
`;
var createProductPrompt = (context) => `
Create a product in PayPal using product catalog - create products API.
This function creates a new product that will be used in subscription plans, subscriptions.
Required parameters are: name (product name), type (product type).
High level: 
    - id: (auto-generated or specify SKU of the product) The ID of the product
    - name: {product_name} (required) 
    - description: {product_description} (optional)
    - type {DIGITAL | PHYSICAL | SERVICE} (required)
    - category: {product_category} (optional) 
    - image_url: {image_url} (optional)
    - home_url: {home_url} (optional)

Below is the payload request structure:
{
    "id": "#PROD-XYAB12ABSB7868434",
    "name": "Video Streaming Service",
    "description": "Service for streaming latest series, movies etc.",
    "type": "SERVICE",
    "category": "SOFTWARE",
    "image_url": "https://example.com/streaming.jpg",
    "home_url": "https://example.com/home"
}

`;
var listProductsPrompt = (context) => `
List products from PayPal.

This function retrieves a list of products with optional pagination parameters.
`;
var showProductDetailsPrompt = (context) => `
List products from PayPal.

This function retrieves a list of products with optional pagination parameters.
`;
var updateProductPrompt = (context) => `
Update a product in PayPal.

This function updates an existing product using JSON Patch operations.
`;
var createSubscriptionPlanPrompt = (context) => `
Create a subsctiption plan in PayPal using subscription - create plan API.
This function creates a new subscription plan that defines pricing and billing cycle details for subscriptions.
Required parameters are: product_id (the ID of the product for which to create the plan), name (subscription plan name), billing_cycles (billing cycle details).
High level: product_id, name, description, taxes, status: {CREATED|INACTIVE|ACTIVE}, billing_cycles, payment_preferences are required in json object.
While creating billing_cycles object, trial(second) billing cycle should precede regular billing cycle.
`;
var listSubscriptionPlansPrompt = (context) => `
List subscription plans from PayPal.

This function retrieves a list of subscription plans with optional product filtering and pagination parameters.
`;
var showSubscriptionPlanDetailsPrompt = (context) => `
Show subscription plan details from PayPal.
This function retrieves the details of a specific subscription plan using its ID.
Required parameters are: plan_id (the ID of the subscription plan).
`;
var createSubscriptionPrompt = (context) => `
Create a subscription in PayPal using the subscription - create subscription API.
This function allows you to create a new subscription for a specific plan, enabling the management of recurring payments.
The only required parameter is plan_id (the ID of the subscription plan). All other fields are optional and can be omitted if not provided.
The subscriber field is optional. If no subscriber information is provided, omit the subscriber field in the request payload.
The shipping address is optional. If no shipping address is provided, set the shipping_preference to GET_FROM_FILE in the application context.
The application context is also optional. If no application context information is provided, omit the application context field in the request payload.
`;
var showSubscriptionDetailsPrompt = (context) => `
Show subscription details from PayPal.
This function retrieves the details of a specific subscription using its ID.
Required parameters are: subscription_id (the ID of the subscription).
`;
var cancelSubscriptionPrompt = (context) => `
Cancel a customer subscription in PayPal.

This function cancels an active subscription for a customer. It requires the subscription ID and an optional reason for cancellation.
Required parameters are: subscription_id (the ID of the subscription to be canceled).
Below is the payload request structure:
{
    "reason": "Customer requested cancellation"
}
You MUST ask the user for: 
 - subscription_id
 - reason for cancellation.

Return all of the above as structured JSON in your response.
`;
var updateSubscriptionPrompt = (context) => `
Update a customer subscription in PayPal.

This function updates an active or suspended subscription for a customer. It requires the subscription ID and payload of allowed keys to update to the subscription.
Required parameters are: subscription_id (the ID of the subscription to be updated), and at-least one key to update

Return response as structured JSON in your response.
`;
var createShipmentPrompt = (context) => `
Create a shipment for a transaction in PayPal.
This function creates a shipment record for a specific transaction, allowing you to track the shipment status and details.
The transaction_id can fetch from the captured payment details in the order information.
Required parameters are: tracking_number (the tracking number for the shipment), transaction_id (the transaction ID associated with the shipment). 
High level: tracking_number, transaction_id, status (optional), carrier (optional) are required json objects.
Below is the payload request structure:
{
    "tracking_number": "1234567890",
    "transaction_id": "9XJ12345ABC67890",
    "status": "SHIPPED", // Required: ON_HOLD, SHIPPED, DELIVERED, CANCELLED
    "carrier": "UPS" // Required: The carrier handling the shipment. Link to supported carriers: http://developer.paypal.com/docs/tracking/reference/carriers/
}
`;
var getShipmentTrackingPrompt = (context) => `
Get tracking information for a shipment by ID.
This function retrieves tracking information for a specific shipment using the transaction ID and tracking number.
The transaction_id can fetch from the captured payment details in the order information.
Below is the payload request structure:
`;
var createOrderPrompt = (context) => `
Create an order in PayPal.

This tool is used to create a new order in PayPal. This is typically the first step in initiating a payment flow. It sets up an order with specified details such as item(s) to be purchased, quantity, amount, currency, and other details.
`;
var getOrderPrompt = (context) => `
Retrieves the order details from PayPal for a given order ID.

This tool is used to retrieve details of an existing order in PayPal. It provides information about the order, including items, amounts, status, and other relevant details.
`;
var captureOrderPrompt = (context) => `
Capture a payment for an order.

This tool is used to capture a payment for an order. It allows you to capture funds that have been authorized for a specific order but not yet captured.
`;
var listDisputesPrompt = (context) => `
List disputes from PayPal.

This function retrieves a list of disputes with optional pagination and filtering parameters.
`;
var getDisputePrompt = (context) => `
Get details for a specific dispute from PayPal.

This tool is used to lists disputes with a summary set of details, which shows the dispute_id, reason, status, dispute_state, dispute_life_cycle_stage, dispute_channel, dispute_amount, create_time and update_time fields.
`;
var acceptDisputeClaimPrompt = (context) => `
Accept liability for a dispute claim.

This tool is used to accept liability for a dispute claim. When you accept liability for a dispute claim, the dispute closes in the customer's favor and PayPal automatically refunds money to the customer from the merchant's account.
`;
var listTransactionsPrompt = (context) => `
List transactions from PayPal.

This tool is used to list transactions with optional filtering parameters within a date range of 31 days. This tool can also be used to list details of a transaction given the transaction ID.

- The start_date and end_date should be specified in ISO8601 date and time format. Example dates: 1996-12-19T16:39:57-08:00, 1985-04-12T23:20:50.52Z, 1990-12-31T23:59:60Z
- The transaction_status accepts the following 4 values:
    1. "D" - represents denied transactions.
    2. "P" - represents pending transactions.
    3. "S" - represents successful transactions.
    4. "V" - represents transactions that were reversed.
- The transaction_id is the unique identifier for the transaction.
`;
var getRefundPrompt = (context) => `
Retrieve detailed information about a PayPal payment refund.
If you have an order ID instead of a refund ID, first use the get order tool to obtain the refund ID from the order details. 
This function returns comprehensive details about a refund, including its current status (completed, pending, cancelled), refunded amount, and processing information.
When multiple refunds exist for an order or capture, request clarification on which specific refund to retrieve. 
Response details include:
- Refund status and ID
- Refunded amount and currency
- Reason for refund (if provided)
- Source transaction details
`;
var createRefundPrompt = (context) => `
Initiate a refund for a PayPal payment capture.
If you have an order ID instead of a capture ID, first use the get order tool to obtain the capture ID from the order details.
This function allows you to return funds to a customer by refunding a previously captured payment. You can issue a full refund or specify a partial amount. If multiple captures exist for an order, request clarification on which specific capture to refund.
Required parameters:
- Capture ID: The ID of the capture to refund
- Amount (optional): For partial refunds, specify the amount to refund (must be less than or equal to the captured amount)
- Note to Payer (optional): Additional explanation visible to the customer
Response details include:
- Refund ID and status
- Refunded amount and currency
`;

// src/shared/parameters.ts
import { z } from "zod";
var invoiceItem = z.object({
  name: z.string().describe("The name of the item"),
  quantity: z.string().describe("The quantity of the item that the invoicer provides to the payer. Value is from -1000000 to 1000000. Supports up to five decimal places. Cast to string"),
  unit_amount: z.object({
    currency_code: z.string().describe("Currency code of the unit amount"),
    value: z.string().describe("The unit price. Up to 2 decimal points")
  }).describe("unit amount object"),
  tax: z.object({
    name: z.string().optional().describe("Tax name"),
    percent: z.string().optional().describe("Tax Percent")
  }).optional().describe("tax object"),
  unit_of_measure: z.enum(["QUANTITY", "HOURS", "AMOUNT"]).optional().describe("The unit of measure for the invoiced item")
}).describe("invoice line item object");
var createInvoiceParameters = (context) => z.object({
  detail: z.object({
    invoice_date: z.string().optional().describe("The invoice date in YYYY-MM-DD format"),
    currency_code: z.string().describe("currency code of the invoice")
  }).describe("The invoice detail"),
  invoicer: z.object({
    business_name: z.string().max(300).describe("business name of the invoicer"),
    name: z.object({
      given_name: z.string().optional().describe("given name of the invoicer"),
      surname: z.string().optional().describe("surname of the invoicer")
    }).optional().describe("name of the invoicer"),
    email_address: z.string().optional().describe("email address of the invoicer")
  }).optional().describe("The invoicer business information that appears on the invoice."),
  primary_recipients: z.array(z.object({
    billing_info: z.object({
      name: z.object({
        given_name: z.string().optional().describe("given name of the recipient"),
        surname: z.string().optional().describe("surname of the recipient")
      }).optional().describe("name of the recipient"),
      email_address: z.string().describe("email address of the recipient").optional()
    }).describe("The billing information of the invoice recipient").optional()
  })).describe("array of recipients").optional(),
  items: z.array(invoiceItem).describe("Array of invoice line items").optional()
}).describe("create invoice request payload");
var getInvoicParameters = (context) => z.object({
  invoice_id: z.string().describe("The ID of the invoice to retrieve.")
});
var listInvoicesParameters = (context) => z.object({
  page: z.number().default(1).optional().describe("The page number of the result set to fetch.").default(1),
  page_size: z.number().min(1).max(100).default(100).optional().describe("The number of records to return per page (maximum 100)."),
  total_required: z.boolean().optional().describe("Indicates whether the response should include the total count of items.")
});
var sendInvoiceParameters = (context) => z.object({
  invoice_id: z.string().describe("The ID of the invoice to send."),
  note: z.string().optional().describe("A note to the recipient."),
  send_to_recipient: z.boolean().optional().describe("Indicates whether to send the invoice to the recipient."),
  additional_recipients: z.array(z.string()).optional().describe("Additional email addresses to which to send the invoice.")
});
var sendInvoiceReminderParameters = (context) => z.object({
  invoice_id: z.string().describe("The ID of the invoice for which to send a reminder."),
  subject: z.string().optional().describe("The subject of the reminder email."),
  note: z.string().optional().describe("A note to the recipient."),
  additional_recipients: z.array(z.string()).optional().describe("Additional email addresses to which to send the reminder.")
});
var cancelSentInvoiceParameters = (context) => z.object({
  invoice_id: z.string().describe("The ID of the invoice to cancel."),
  note: z.string().optional().describe("A cancellation note to the recipient."),
  send_to_recipient: z.boolean().optional().describe("Indicates whether to send the cancellation to the recipient."),
  additional_recipients: z.array(z.string()).optional().describe("Additional email addresses to which to send the cancellation.")
});
var generateInvoiceQrCodeParameters = (context) => z.object({
  invoice_id: z.string().describe("The invoice id to generate QR code for"),
  width: z.number().default(300).describe("The QR code width"),
  height: z.number().default(300).describe("The QR code height")
}).describe("generate invoice qr code request payload");
var updateProductParameters = (context) => z.object({
  product_id: z.string().describe("The ID of the product to update."),
  operations: z.array(z.object({}).passthrough()).describe("The PATCH operations to perform on the product.")
});
var createShipmentParameters = (context) => z.object({
  order_id: z.string().describe("The ID of the order for which to create a shipment").optional(),
  tracking_number: z.string().describe("The tracking number for the shipment. Id is provided by the shipper. This is required to create a shipment."),
  transaction_id: z.string().describe("The transaction ID associated with the shipment. Transaction id available after the order is paid or captured. This is required to create a shipment."),
  status: z.string().optional().describe('The status of the shipment. It can be "ON_HOLD", "SHIPPED", "DELIVERED", or "CANCELLED".').default("SHIPPED"),
  carrier: z.string().optional().describe("The carrier handling the shipment.")
});
var getShipmentTrackingParameters = (context) => z.object({
  order_id: z.string().describe("The ID of the order for which to create a shipment.").optional(),
  transaction_id: z.string().describe("The transaction ID associated with the shipment tracking to retrieve.").optional()
});
var itemDetails = z.object({
  itemCost: z.number().describe("The cost of each item - upto 2 decimal points."),
  taxPercent: z.number().describe("The tax percent for the specific item.").default(0),
  itemTotal: z.number().describe("The total cost of this line item.")
});
var lineItem = z.object({
  name: z.string().describe("The name of the item."),
  quantity: z.number().describe("The item quantity. Must be a whole number.").default(1),
  description: z.string().describe("The detailed item description.").optional()
}).merge(itemDetails);
var shippingAddress = z.object({
  address_line_1: z.string().describe("The first line of the address, such as number and street, for example, `173 Drury Lane`.This field needs to pass the full address.").optional(),
  address_line_2: z.string().describe(`The second line of the address, for example, a suite or apartment number.`).optional(),
  admin_area_2: z.string().describe("A city, town, or village. Smaller than `admin_area_level_1`.").optional(),
  admin_area_1: z.string().describe("The highest-level sub-division in a country, which is usually a province, state, or ISO-3166-2 subdivision. ").optional(),
  postal_code: z.string().describe("The postal code, which is the ZIP code or equivalent. Typically required for countries with a postal code or an equivalent.").optional(),
  country_code: z.string().describe("The 2-character ISO 3166-1 code that identifies the country or region. Note: The country code for Great Britain is `GB` and not `UK` as used in the top-level domain names for that country.").length(2).optional()
}).describe("The shipping address for the order.");
var createOrderParameters = (context) => z.object({
  currencyCode: z.enum(["USD"]).describe("Currency code of the amount."),
  items: z.array(z.lazy(() => lineItem)).max(50),
  discount: z.number().describe("The discount amount for the order.").default(0).optional(),
  shippingCost: z.number().describe("The cost of shipping for the order.").default(0).optional(),
  shippingAddress: z.optional(shippingAddress.nullable()).default(null).describe("The shipping address for the order."),
  notes: z.string().optional().nullable().default(null),
  returnUrl: z.string().optional().default("https://example.com/returnUrl"),
  cancelUrl: z.string().optional().default("https://example.com/cancelUrl")
});
var getOrderParameters = (context) => z.object({
  id: z.string().describe("The order id generated during create call")
});
var captureOrderParameters = (context) => z.object({
  id: z.string().describe("The order id generated during create call")
});
var listDisputesParameters = (context) => z.object({
  disputed_transaction_id: z.string().nullable().default(null),
  dispute_state: z.enum([
    "REQUIRED_ACTION",
    "REQUIRED_OTHER_PARTY_ACTION",
    "UNDER_PAYPAL_REVIEW",
    "RESOLVED",
    "OPEN_INQUIRIES",
    "APPEALABLE"
  ]).optional().describe("OPEN_INQUIRIES"),
  page_size: z.number().default(10).optional(),
  page: z.number().default(1).optional()
});
var getDisputeParameters = (context) => z.object({
  dispute_id: z.string().describe("The order id generated during create call")
});
var acceptDisputeClaimParameters = (context) => z.object({
  dispute_id: z.string(),
  note: z.string().describe("A note about why the seller is accepting the claim")
});
var listTransactionsParameters = (context) => z.object({
  transaction_id: z.string().optional().describe("The ID of the transaction to retrieve.").nullable().default(null),
  transaction_status: z.enum([
    "D",
    "P",
    "S",
    "V"
  ]).optional().default("S"),
  start_date: z.string().describe("Filters the transactions in the response by a start date and time, in ISO8601 date and time format. Seconds are required. Fractional seconds are optional.").optional().default(() => {
    const now = /* @__PURE__ */ new Date();
    now.setDate(now.getDate() - 31);
    return now.toISOString();
  }),
  end_date: z.string().describe("Filters the transactions in the response by an end date and time, in ISO8601 date and time format. Seconds are required. Fractional seconds are optional. The maximum supported range is 31 days.").optional().default(() => {
    const now = /* @__PURE__ */ new Date();
    now.setDate(now.getDate());
    return now.toISOString();
  }),
  search_months: z.number().optional().describe("Number of months to search back for a transaction by ID. Default is 12 months.").default(12),
  page_size: z.number().default(100).optional(),
  page: z.number().default(1).optional()
});
var createProductParameters = (context) => z.object({
  name: z.string().describe("The product name."),
  type: z.enum(["PHYSICAL", "DIGITAL", "SERVICE"]).describe("The product type. Value is PHYSICAL, DIGITAL, or SERVICE."),
  description: z.string().optional().describe("The product description."),
  category: z.string().optional().describe("The product category."),
  image_url: z.string().optional().describe("The image URL for the product."),
  home_url: z.string().optional().describe("The home page URL for the product.")
});
var listProductsParameters = (context) => z.object({
  page: z.number().optional().describe("The page number of the result set to fetch."),
  page_size: z.number().optional().describe("The number of records to return per page (maximum 100)."),
  total_required: z.boolean().optional().describe("Indicates whether the response should include the total count of products.")
});
var showProductDetailsParameters = (context) => z.object({
  product_id: z.string().describe("The ID of the product to update.")
});
var frequencySchema = z.object({
  interval_unit: z.enum(["DAY", "WEEK", "MONTH", "YEAR"]).describe("The unit of time for the billing cycle."),
  interval_count: z.number().describe("The number of units for the billing cycle.")
}).passthrough();
var fixedPriceSchema = z.object({
  currency_code: z.enum(["USD"]).describe("The currency code for the fixed price."),
  value: z.string().describe("The value of the fixed price.")
}).passthrough().optional().describe("The fixed price for the subscription plan.");
var pricingSchemeSchema = z.object({
  fixed_price: fixedPriceSchema,
  version: z.string().optional().describe("The version of the pricing scheme.")
}).passthrough();
var billingCycleSchema = z.object({
  frequency: frequencySchema.describe("The frequency of the billing cycle."),
  tenure_type: z.enum(["REGULAR", "TRIAL"]).describe("The type of billing cycle tenure."),
  sequence: z.number().describe("The sequence of the billing cycle."),
  total_cycles: z.number().optional().describe("The total number of cycles in the billing plan."),
  pricing_scheme: pricingSchemeSchema.describe("The pricing scheme for the billing cycle.")
}).passthrough();
var setupFeeSchema = z.object({
  currency_code: z.enum(["USD"]).optional().describe("The currency code for the setup fee."),
  value: z.string().optional().describe("The value of the setup fee.")
}).passthrough().optional();
var autoBillOutstandingSchema = z.boolean().optional().describe("Indicates whether to automatically bill outstanding amounts.");
var paymentFailureThresholdSchema = z.number().optional().describe("The number of failed payments before the subscription is canceled.");
var paymentPreferencesSchema = z.object({
  auto_bill_outstanding: autoBillOutstandingSchema,
  setup_fee: setupFeeSchema.describe("The setup fee for the subscription plan."),
  setup_fee_failure_action: z.enum(["CONTINUE", "CANCEL"]).optional().describe("The action to take if the setup fee payment fails."),
  payment_failure_threshold: paymentFailureThresholdSchema
}).passthrough().optional();
var taxPercentageSchema = z.string().optional().describe("The tax percentage.");
var taxInclusiveSchema = z.boolean().optional().describe("Indicates whether the tax is inclusive.");
var taxesSchema = z.object({
  percentage: taxPercentageSchema,
  inclusive: taxInclusiveSchema
}).passthrough().optional();
var createSubscriptionPlanParameters = (context) => z.object({
  product_id: z.string().describe("The ID of the product for which to create the plan."),
  name: z.string().describe("The subscription plan name."),
  description: z.string().optional().describe("The subscription plan description."),
  billing_cycles: z.array(billingCycleSchema).describe("The billing cycles of the plan."),
  payment_preferences: paymentPreferencesSchema.describe("The payment preferences for the subscription plan."),
  taxes: taxesSchema.describe("The tax details.")
});
var listSubscriptionPlansParameters = (context) => z.object({
  product_id: z.string().optional().describe("The ID of the product for which to get subscription plans."),
  page: z.number().optional().describe("The page number of the result set to fetch."),
  page_size: z.number().optional().describe("The number of records to return per page (maximum 100)."),
  total_required: z.boolean().optional().describe("Indicates whether the response should include the total count of plans.")
});
var showSubscriptionPlanDetailsParameters = (context) => z.object({
  plan_id: z.string().describe("The ID of the subscription plan to show.")
});
var NameSchema = z.object({
  given_name: z.string().optional().describe("The subscriber given name."),
  surname: z.string().optional().describe("The subscriber last name.")
}).optional().describe("The subscriber name.");
var AddressSchema = z.object({
  address_line_1: z.string().describe("The first line of the address."),
  address_line_2: z.string().optional().describe("The second line of the address."),
  admin_area_1: z.string().describe("The city or locality."),
  admin_area_2: z.string().describe("The state or province."),
  postal_code: z.string().describe("The postal code."),
  country_code: z.enum(["US"]).describe("The country code.")
}).optional().describe("The shipping address.");
var ShippingAddressSchema = z.object({
  name: NameSchema.describe("The subscriber shipping address name."),
  address: AddressSchema
}).optional().describe("The subscriber shipping address.");
var PaymentMethodSchema = z.object({
  payer_selected: z.enum(["PAYPAL", "CREDIT_CARD"]).describe("The payment method selected by the payer."),
  payee_preferred: z.enum(["IMMEDIATE_PAYMENT_REQUIRED", "INSTANT_FUNDING_SOURCE"]).optional().describe("The preferred payment method for the payee.")
}).optional().describe("The payment method details.");
var ShippingAmount = z.object({
  currency_code: z.enum(["USD"]).describe("The currency code for the shipping amount."),
  value: z.string().describe("The value of the shipping amount.")
}).optional().describe("The shipping amount for the subscription.");
var Subscriber = z.object({
  name: NameSchema,
  email_address: z.string().optional().describe("The subscriber email address."),
  shipping_address: ShippingAddressSchema
}).optional().describe("The subscriber details.");
var ApplicationContext = z.object({
  brand_name: z.string().describe("The brand name."),
  locale: z.string().optional().describe("The locale for the subscription."),
  shipping_preference: z.enum(["SET_PROVIDED_ADDRESS", "GET_FROM_FILE"]).optional().describe("The shipping preference."),
  user_action: z.enum(["SUBSCRIBE_NOW", "CONTINUE"]).optional().describe("The user action."),
  return_url: z.string().describe("The return URL after the subscription is created."),
  cancel_url: z.string().describe("The cancel URL if the user cancels the subscription."),
  payment_method: PaymentMethodSchema
}).optional().describe("The application context for the subscription.");
var createSubscriptionParameters = (context) => z.object({
  plan_id: z.string().describe("The ID of the subscription plan to create."),
  quantity: z.number().optional().describe("The quantity of the product in the subscription."),
  shipping_amount: ShippingAmount,
  subscriber: Subscriber,
  application_context: ApplicationContext
});
var showSubscriptionDetailsParameters = (context) => z.object({
  subscription_id: z.string().describe("The ID of the subscription to show details."),
  get_additional_details: z.boolean().optional().describe("Get all detailed information for the subscription.")
});
var cancelSubscriptionParameters = (context) => z.object({
  subscription_id: z.string().describe("The ID of the subscription to show details."),
  payload: z.object({
    reason: z.string().describe("The reason for the cancellation of a subscription.")
  }).passthrough().describe("Payload for subscription cancellation.")
});
var updateSubscriptionParameters = (context) => z.object({
  ["subscription_id" /* subscriptionId */]: z.string().describe("The ID of the subscription to update."),
  ["currency_code" /* currencyCode */]: z.enum(["USD"]).optional().default("USD").describe("Currency code of the amount."),
  ["outstanding_balance" /* outstandingBalance */]: z.string().optional().describe("Outstanding Balance in the subscription"),
  ["custom_id" /* customId */]: z.string().optional().describe("The custom id for the subscription"),
  ["fixed_price" /* fixedPrice */]: z.object({
    value: z.string().describe("The fixed price for the subscription."),
    sequence: z.number().describe("The order sequence for the billing cycles")
  }).optional().describe("The fixed price for a billing cycle."),
  ["payment_failure_threshold" /* paymentFailureThreshold */]: paymentFailureThresholdSchema,
  ["auto_bill_outstanding" /* autoBillOutstanding */]: autoBillOutstandingSchema,
  ["taxes_inclusive" /* taxesInclusive */]: taxInclusiveSchema,
  ["taxes_percentage" /* taxesPercentage */]: taxPercentageSchema,
  ["shipping_amount" /* shippingAmount */]: z.string().optional().describe("The value of the shipping amount."),
  ["shipping_address" /* shippingAddress */]: ShippingAddressSchema.optional().describe("The shipping address.")
});
var getRefundParameters = (context) => z.object({
  refund_id: z.string().describe("The ID of the refund to get details for.")
});
var createRefundParameters = (context) => z.object({
  capture_id: z.string().describe("The ID of the capture to refund."),
  amount: z.object({
    currency_code: z.string(),
    value: z.string()
  }).optional().describe("The amount to refund. If not specified, the full captured amount is refunded."),
  invoice_id: z.string().optional().describe("The invoice ID that is used to track this payment."),
  note_to_payer: z.string().optional().describe("A note to the payer.")
});

// src/shared/tools.ts
var tools = (context) => [
  {
    method: "create_invoice",
    name: "Create Invoice",
    description: createInvoicePrompt(context),
    parameters: createInvoiceParameters(context),
    actions: {
      invoices: {
        create: true
      }
    }
  },
  {
    method: "list_invoices",
    name: "List Invoices",
    description: listInvoicesPrompt(context),
    parameters: listInvoicesParameters(context),
    actions: {
      invoices: {
        list: true
      }
    }
  },
  {
    method: "get_invoice",
    name: "Get Invoice",
    description: getInvoicePrompt(context),
    parameters: getInvoicParameters(context),
    actions: {
      invoices: {
        get: true
      }
    }
  },
  {
    method: "send_invoice",
    name: "Send Invoice",
    description: sendInvoicePrompt(context),
    parameters: sendInvoiceParameters(context),
    actions: {
      invoices: {
        send: true
      }
    }
  },
  {
    method: "send_invoice_reminder",
    name: "Send Invoice Reminder",
    description: sendInvoiceReminderPrompt(context),
    parameters: sendInvoiceReminderParameters(context),
    actions: {
      invoices: {
        sendReminder: true
      }
    }
  },
  {
    method: "cancel_sent_invoice",
    name: "Cancel Sent Invoice",
    description: cancelSentInvoicePrompt(context),
    parameters: cancelSentInvoiceParameters(context),
    actions: {
      invoices: {
        cancel: true
      }
    }
  },
  {
    method: "generate_invoice_qr_code",
    name: "Generate Invoice QR Code",
    description: generateInvoiceQrCodePrompt(context),
    parameters: generateInvoiceQrCodeParameters(context),
    actions: {
      invoices: {
        generateQRC: true
      }
    }
  },
  {
    method: "create_product",
    name: "Create Product",
    description: createProductPrompt(context),
    parameters: createProductParameters(context),
    actions: {
      products: {
        create: true
      }
    }
  },
  {
    method: "list_products",
    name: "List Products",
    description: listProductsPrompt(context),
    parameters: listProductsParameters(context),
    actions: {
      products: {
        list: true
      }
    }
  },
  {
    method: "update_product",
    name: "Update Product",
    description: updateProductPrompt(context),
    parameters: updateProductParameters(context),
    actions: {
      products: {
        update: true
      }
    }
  },
  {
    method: "show_product_details",
    name: "Show Products Details",
    description: showProductDetailsPrompt(context),
    parameters: showProductDetailsParameters(context),
    actions: {
      products: {
        show: true
      }
    }
  },
  {
    method: "create_subscription_plan",
    name: "Create Subscription Plan",
    description: createSubscriptionPlanPrompt(context),
    parameters: createSubscriptionPlanParameters(context),
    actions: {
      subscriptionPlans: {
        create: true
      }
    }
  },
  {
    method: "list_subscription_plans",
    name: "List Subscription Plans",
    description: listSubscriptionPlansPrompt(context),
    parameters: listSubscriptionPlansParameters(context),
    actions: {
      subscriptionPlans: {
        list: true
      }
    }
  },
  {
    method: "show_subscription_plan_details",
    name: "Show Subscription Plan Details",
    description: showSubscriptionPlanDetailsPrompt(context),
    parameters: showSubscriptionPlanDetailsParameters(context),
    actions: {
      subscriptionPlans: {
        show: true
      }
    }
  },
  {
    method: "create_subscription",
    name: "Create Subscription",
    description: createSubscriptionPrompt(context),
    parameters: createSubscriptionParameters(context),
    actions: {
      subscriptions: {
        create: true
      }
    }
  },
  {
    method: "show_subscription_details",
    name: "Show Subscription Details",
    description: showSubscriptionDetailsPrompt(context),
    parameters: showSubscriptionDetailsParameters(context),
    actions: {
      subscriptions: {
        show: true
      }
    }
  },
  {
    method: "cancel_subscription",
    name: "Cancel Subscription",
    description: cancelSubscriptionPrompt(context),
    parameters: cancelSubscriptionParameters(context),
    actions: {
      subscriptions: {
        cancel: true
      }
    }
  },
  {
    method: "update_subscription",
    name: "Update Subscription",
    description: updateSubscriptionPrompt(context),
    parameters: updateSubscriptionParameters(context),
    actions: {
      subscriptions: {
        update: true
      }
    }
  },
  {
    method: "create_shipment_tracking",
    name: "Create shipment",
    description: createShipmentPrompt(context),
    parameters: createShipmentParameters(context),
    actions: {
      shipment: {
        create: true
      }
    }
  },
  {
    method: "get_shipment_tracking",
    name: "Get Shipment Tracking",
    description: getShipmentTrackingPrompt(context),
    parameters: getShipmentTrackingParameters(context),
    actions: {
      shipment: {
        get: true
      }
    }
  },
  {
    method: "create_order",
    name: "Create Order",
    description: createOrderPrompt(context),
    parameters: createOrderParameters(context),
    actions: {
      orders: {
        create: true
      }
    }
  },
  {
    method: "get_order",
    name: "Get Order",
    description: getOrderPrompt(context),
    parameters: getOrderParameters(context),
    actions: {
      orders: {
        get: true
      }
    }
  },
  {
    method: "pay_order",
    name: "Process payment for an authorized order",
    description: captureOrderPrompt(context),
    parameters: captureOrderParameters(context),
    actions: {
      orders: {
        capture: true
      }
    }
  },
  {
    method: "list_disputes",
    name: "List Disputes",
    description: listDisputesPrompt(context),
    parameters: listDisputesParameters(context),
    actions: {
      disputes: {
        list: true
      }
    }
  },
  {
    method: "get_dispute",
    name: "Get Dispute",
    description: getDisputePrompt(context),
    parameters: getDisputeParameters(context),
    actions: {
      disputes: {
        get: true
      }
    }
  },
  {
    method: "accept_dispute_claim",
    name: "Accept dispute claim",
    description: acceptDisputeClaimPrompt(context),
    parameters: acceptDisputeClaimParameters(context),
    actions: {
      disputes: {
        create: true
      }
    }
  },
  {
    method: "list_transactions",
    name: "List Transactions",
    description: listTransactionsPrompt(context),
    parameters: listTransactionsParameters(context),
    actions: {
      transactions: {
        list: true
      }
    }
  },
  {
    method: "create_refund",
    name: "Create Refund",
    description: createRefundPrompt(context),
    parameters: createRefundParameters(context),
    actions: {
      payments: {
        createRefund: true
      }
    }
  },
  {
    method: "get_refund",
    name: "Get Refund",
    description: getRefundPrompt(context),
    parameters: getRefundParameters(context),
    actions: {
      payments: {
        getRefunds: true
      }
    }
  }
];
var allActions = tools({}).reduce((acc, tool) => {
  Object.keys(tool.actions).forEach((product) => {
    acc[product] = { ...acc[product], ...tool.actions[product] };
  });
  return acc;
}, {});
var tools_default = tools;

// src/modelcontextprotocol/toolkit.ts
var SOURCE = "MCP";
var PayPalAgentToolkit = class extends McpServer {
  _paypal;
  constructor({
    accessToken,
    configuration
  }) {
    super({
      name: "PayPal",
      version
    });
    this._paypal = new api_default(accessToken, { ...configuration.context, source: SOURCE });
    const context = configuration.context || {};
    const filteredTools = tools_default(context).filter(
      (tool) => isToolAllowed(tool, configuration)
    );
    filteredTools.forEach((tool) => {
      const regTool = this.tool(
        tool.method,
        tool.description,
        tool.parameters.shape,
        async (arg, _extra) => {
          const result = await this._paypal.run(tool.method, arg);
          return {
            content: [
              {
                type: "text",
                text: String(result)
              }
            ]
          };
        }
      );
    });
  }
};
var toolkit_default = PayPalAgentToolkit;

// src/modelcontextprotocol/mcpToolkit.ts
var SOURCE2 = "Remote MCP";
var PayPalMCPToolkit = class {
  _paypal;
  filteredTools = [];
  constructor({
    accessToken,
    configuration
  }) {
    this._paypal = new api_default(accessToken, { ...configuration.context, source: SOURCE2 });
    const context = configuration.context || {};
    this.filteredTools = tools_default(context).filter(
      (tool) => isToolAllowed(tool, configuration)
    );
  }
  getTools() {
    return this.filteredTools;
  }
  getPaypalAPIService() {
    return this._paypal;
  }
};
var mcpToolkit_default = PayPalMCPToolkit;
export {
  api_default as PayPalAPI,
  toolkit_default as PayPalAgentToolkit,
  mcpToolkit_default as PayPalMCPToolkit
};
//# sourceMappingURL=index.mjs.map